# module cpp

### todo
- check cpp00 avec valgrind
- demander si iostream et iomanip sont des bibliothèques externes parce que c'est pas autorisé dans la correction
"L'utilisation d'une bibliothèque externe, ou de fonctionnalités propres aux versions postérieures à C++98."
- check le pblm dans le phonebook.hpp ex01
- ajouter les header42
- faire en sorte d'avoir les fichier .d c'est pratique

Retour de dhubleur (Damien) sur mes class :
Compliqué à dire comme ça faudrait voir l implémentation mais ce que je vois c est
- il manque des includes. Genre <string>
- en général on prefix les trucs privés par _ et pas postfix
- pour moi ta classe contact devrait pas stocker son index, dans l idée ça ne fait pas sens dans le contexte 
d un contact de savoir son index. Ça fait sens uniquement dans le cadre du phonebook ou il est avec 
d autres contacts. C est de la semantique pas trop grave mais c est important comme 
concept de se poser la question: cette variable a t elle réellement du sens a être dans cette 
classe, est elle réellement reliée à cette classe ?
- toujours sur cette variable index, elle est en public alors que t as aussi un accesseur (updateIndex).
Soit tu mets la variable en privé et tu fais des accesseurs soit tu la mets en public et ducoup ps d accesseurs 
mais pas un mélange des 2
- difficile à dire sans contexte mais initNewContact fait penser à un constructeur, je vois pas bien pourquoi
elle existe mais je l appellerai plutôt fillContact ou quelque chose comme ça
Globalement tu semble avoir bien compris les concepts de base en tout cas

tellement reconnaissant !




============================================================================================================================================================================================================================================================================================================
Pour l'ex01 =================================
Pour reproduire le comportement d'un shell Bash en C++ qui attend en permanence une entrée de l'utilisateur et gère correctement les signaux tels que CTRL + D et CTRL + C, vous pouvez utiliser une boucle de lecture d'entrée et une gestion des signaux à l'aide de la bibliothèque `<csignal>`.

Voici un exemple de code qui illustre cela :

```cpp
#include <iostream>
#include <csignal>

// Fonction de gestion du signal SIGINT (CTRL + C)
void gestionnaire_SIGINT(int signal) {
    std::cout << "Signal SIGINT (CTRL+C) reçu." << std::endl;
    // Ajoutez ici le code que vous voulez exécuter en cas de signal SIGINT
}

// Fonction de gestion du signal SIGQUIT (CTRL + D)
void gestionnaire_SIGQUIT(int signal) {
    std::cout << "Signal SIGQUIT (CTRL+D) reçu." << std::endl;
    // Ajoutez ici le code que vous voulez exécuter en cas de signal SIGQUIT
}

int main() {
    // Installation des gestionnaires de signaux
    signal(SIGINT, gestionnaire_SIGINT); // Gestionnaire pour CTRL+C
    signal(SIGQUIT, gestionnaire_SIGQUIT); // Gestionnaire pour CTRL+D

    // Boucle d'attente de l'entrée de l'utilisateur
    while (true) {
        std::string entree;
        std::cout << "Entrez une commande (ou CTRL+D pour quitter) : ";
        if (!(std::getline(std::cin, entree))) {
            // Si std::getline renvoie false, cela signifie que CTRL+D a été pressé
            std::cout << "Fin du programme." << std::endl;
            break;
        }
        // Traitez ici l'entrée de l'utilisateur
        std::cout << "Vous avez saisi : " << entree << std::endl;
    }

    return 0;
}
```

Dans cet exemple :

- Nous avons défini deux fonctions de gestion des signaux, `gestionnaire_SIGINT` pour SIGINT (CTRL + C) et `gestionnaire_SIGQUIT` pour SIGQUIT (CTRL + D).
- Nous avons installé ces gestionnaires de signaux à l'aide de la fonction `signal`.
- Dans la boucle principale, nous utilisons `std::getline` pour lire une ligne d'entrée de l'utilisateur. Si `std::getline` renvoie `false`, cela signifie que CTRL + D a été pressé et nous quittons la boucle.
- Vous pouvez insérer votre logique de traitement de l'entrée de l'utilisateur à l'intérieur de la boucle.

Ainsi, ce programme réplique le comportement d'un shell en C++, attendant en permanence une entrée de l'utilisateur et gérant les signaux CTRL + D et CTRL + C.


============================================================================================================================================================================================================================================================================================================


Attention ce passage:
Vous devez pouvoir utiliser vos fichiers d’en-tête séparément les uns des autres.
C’est pourquoi ils devront inclure toutes les dépendances qui leur seront nécessaires. Cependant, vous devez éviter le problème de la double inclusion en les
protégeant avec des include guards. Dans le cas contraire, votre note sera de 0


Comprendre ceci:
• Une fonction implémentée dans un fichier d’en-tête (hormis dans le cas de fonction
template) équivaudra à la note de 0.

