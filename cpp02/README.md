# C++ Module 02
## Table of Contents
- [Ex00](#ex00)
- [Ex01](#ex01)
- [Ex02](#ex02)

### Introduction
Polymorphisme ad-hoc <=> surcharge de fonctions\
**Definition** : Une fonction est dite surchargÃ©e si elle a plusieurs dÃ©finitions, mais avec des paramÃ¨tres diffÃ©rents.
```
void	foo(int a)
{
	cout << "int" << endl;
}

void	foo(float a)
{
	cout << "float" << endl;
}

void	foo(double a) 
{
	cout << "double" << endl;
}
```


Trois facon d'ecrire une operation arithmetique simple :
```bash
#Notation infix
1 + 1

#Notation prefix (fonctionnelle)
+ 1 1
+(1, 1)

#Notation postfix
1 1 +
```

### La forme canonique de Coplien
Ã€ partir de maintenant, vos classes devront impÃ©rativement se conformer Ã  la forme
canonique de Coplien, sauf en cas dâ€™indication contraire. Cela signifie quâ€™elles devront
comporter les quatre fonctions membres suivantes :
- Constructeur par dÃ©faut
- Constructeur de recopie
- OpÃ©rateur dâ€™affectation
- Destructeur

**Voici une sorte de template avec cette class Sample :**
```cpp
#ifndef SAMPLE_HPP
# define SAMPLE_HPP

#include <iostream>

class Sample {

public:
	Sample(void);							// âœ… Constructeur par dÃ©faut 
	Sample(const int n);					// ðŸ†— Bonne pratique ce constructeur
	Sample(const Sample &rhs);				// âœ… Constructeur de recopie
	Sample	&operator=(const Sample &rhs);	// âœ… OpÃ©rateur dâ€™affectation
	~Sample(void);							// âœ… Destructeur

	const int	getFoo(void);				// ðŸ†— Bonne pratique cet accesseur

private:
	int	foo_;								// ðŸ†— Bonne pratique le _

};

// ðŸ†— Bonne pratique
std::operator	&operator<<(std::ostream &o, const Sample &i);

#endif
```
**Maintenant voyons voir le code de ces fonctions :**
```cpp
#include "Sample.hpp"

Sample::Sample(void) : foo_(0) {
	std::cout << "Constructor called" << std::endl;
	return ;
}

Sample::Sample(const int n) : foo_(n) {
	std::cout << "Parametric constructor called" << std::endl;
	return ;
}

Sample::Sample(const Sample &rhs) {
	std::cout << "Copy constructor called" << std::endl;
	*this = rhs;
	return ;
}

Sample	&Sample::operator=(const Sample &rhs) {
	std::cout << "Assignation operator called" << std::endl;
	this->foo_ = rhs.getFoo();
	return (*this);
}

Sample::~Sample(void) {
	std::cout << "Destructor called" << std::endl;
	return ;
}

const int	Sample::getFoo(void) {
	return (this->foo_);
}

std::operator	&operator<<(std::ostream &o, const Sample &i) {
	o << i.getFoo();
	return (o);
}
```
**Et voici un exemple d'utilisation de cette classe :**
```cpp
#include "Sample.hpp"

int		main(void) {
	Sample	instance1;
	Sample	instance2( 42 );
	Sample	instance3( instance1 );

	std::cout << "instance1 : " << instance1 << std::endl;
	std::cout << "instance2 : " << instance2 << std::endl;
	std::cout << "instance3 : " << instance3 << std::endl;

	instance3 = instance2;
	std::cout << "instance3 : " << instance3 << std::endl;
	return (0);
}
```

### Ex00
les entiers	-> des briques\
les floats	-> de la pÃ¢te Ã  modeler\
Facile de faire une sphÃ¨re avec de la pÃ¢te Ã  modeler, mais pas avec des briques.\
Facile de faire un cube parfait avec des briques, mais pas avec de la pÃ¢te Ã  modeler (les coins notamment, seront difficile Ã  faire).\

Les nombres Ã  virgule flottante <=> Les flottants\

Les nombres Ã  virgule flottante (ou flottants) sont une maniÃ¨re de reprÃ©senter des nombres rÃ©els en informatique.\

Dans la vie rÃ©elle, 1 / 3 = 0.333333333333[...]âˆž\
Le resultat de 1 / 3 est un nombre Ã  virgule floatante.\
Aucune reprÃ©sentation dÃ©cimale finie (par exemple 0,333333) ne peut Ãªtre Ã©gale Ã  1/3 ; il n'y a jamais assez de 3.\

Mettre un const a la fin d'une fonction permet de dire que la fonction ne modifie pas l'objet.\
En C++, la position du mot-clÃ© const dans une dÃ©claration de fonction a une signification importante. Lorsqu'il est placÃ© Ã  la fin de la dÃ©claration de fonction, comme dans l'exemple que vous avez donnÃ©, cela signifie que la fonction ne modifie pas l'Ã©tat de l'objet sur lequel elle est appelÃ©e.\

Dans le cas de la fonction getRawBits que vous avez montrÃ©e, le fait de placer const Ã  la fin signifie que cette fonction est une fonction constante. Cela indique que la fonction ne modifie pas les membres de l'objet sur lequel elle est appelÃ©e. En d'autres termes, elle ne modifie pas l'Ã©tat interne de l'objet.\

L'utilisation du mot-clÃ© const Ã  la fin d'une dÃ©claration de fonction est une bonne pratique de programmation, car cela permet de spÃ©cifier clairement l'intention de ne pas modifier l'objet. Cela peut Ã©galement aider le compilateur Ã  dÃ©tecter les erreurs si vous essayez de modifier l'objet Ã  l'intÃ©rieur de la fonction.\
```cpp
int		getRawBits( void ) const;
```
Si on met le const autre part :
```cpp
const int	getRawBits( void );
// or
int const	getRawBits( void );
```
Cela signifie que la valeur de retour de la fonction est constante. Cela signifie que la valeur retournÃ©e par la fonction ne peut pas Ãªtre modifiÃ©e.\

### Comprendre les bits
Un bit c'est comme un interrupteur qui peut Ãªtre soit allumÃ© (1) soit Ã©teint (0).\
Si on a un seul interrupteur, on peut avoir 0 ou 1.\
Quand j'ecris le nombre 2042, j'utilise une base 10 dans laquelle je peux piocher des chiffres dans {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}.\
Quand je fonctionne avec des interrupteurs, je suis en base 2 c'est comme si je ne pouvais piocher que dans {0, 1}.\

0 en base 10 = 0 en base 2\
1 en base 10 = 1 en base 2\
Pour pouvoir reprÃ©senter 2,3,4,5 et plus, qui sont des nombres en base 10, il faut que j'utilise plusieurs interrupteurs.\

Si je veux reprÃ©senter 42 en base 10, je vais devoir utiliser plusieurs interrupteurs :
```bash
101010
```
101010 c'est un nombre en base 2 tout comme 1999 est un nombre en base 10.\

Pour passe d'un nombre en base 10 Ã  un nombre en base 2, et inversement, il y a plusieurs mÃ©thodes.\
*Je t'invite Ã  chercher par toi mÃªme comment convertir un nombre d'une base vers une autre.*\

42 en base 10 = 101010 en base 2
```bash
101010 -> 2^5 * 1 + 2^4 * 0 + 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 0
101010 -> 32 + 0 + 8 + 0 + 2 + 0
101010 -> 42
# Voici comment on converti un nombre en base 2 en base 10
```
Quand j'ecris 101010, c'est comme si j'avais utilisÃ© 6 interrupteurs pour reprÃ©senter le nombre 42 (qui lui est en base 10).\
Si je veux, je peux utiliser 8 interrupteurs pour reprÃ©senter un nombre. J'ai juste Ã  rajouter des interrupteurs derrriÃ¨re.\
```bash
001010101 -> 2^7 * 0 + 2^6 * 0 + 2^5 * 1 + 2^4 * 0 + 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 1
001010101 -> 0 + 0 + 32 + 0 + 8 + 0 + 2 + 1
001010101 -> 42
```
Si je rajoute des interrupteurs Ã  gauche, je vais augmenter la valeur du nombre parce que les puissances de 2 vont augmenter.\
Si je rajoute des interrupteurs Ã  droite, je vais augmenter la prÃ©cision du nombre.\
```bash
01010101 -> 2^7 * 0 + 2^6 * 0 + 2^5 * 1 + 2^4 * 0 + 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 1
01010101 -> 0 + 0 + 32 + 0 + 8 + 0 + 2 + 1
01010101 -> 43

01101010 -> 2^7 * 0 + 2^6 * 1 + 2^5 * 1 + 2^4 * 0 + 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 0
01101010 -> 0 + 64 + 32 + 0 + 8 + 0 + 2 + 0
01101010 -> 106
```
En mettant des interrupteurs Ã  gauche, j'ai augmentÃ© la valeur du nombre.\
En mettant des interrupteurs Ã  droite, j'ai augmentÃ© la prÃ©cision du nombre. Dans cette exemple, je suis passÃ© de 42 Ã  43 mais si j'avais un nombre a virgule, j'aurais pu avoir plus de prÃ©cision.\

**Mais comment reprÃ©senter un nombre a virgule en binaire ?**\
Si je veux reprÃ©senter 42.75 en binaire, je vais devoir utiliser des interrupteurs pour la partie entiÃ¨re et des interrupteurs pour la partie dÃ©cimale.\
```bash
101010.11

101010 -> 42
11 -> 0.75
```

Bizarement, 11 en base 2 = 3 en base 10 et non pas 0.75.\
On a utilisÃ© des puissance nÃ©gatives de 2 pour reprÃ©senter la partie dÃ©cimale, celle qui vient aprÃ¨s la virgule.
```bash
11 -> 2^(-1) * 1 + 2^(-2) * 1
11 -> 0.5 + 0.25
11 -> 0.75
```

Comment savoir si on peut utilise 1, 5, 8 ou 1000 interrupteurs pour reprÃ©senter un nombre ?\
En informatique, on utilise des types de donnÃ©es pour dÃ©finir combien d'interrupteurs on va utiliser.\
```cpp
int		n; // 4 octets
float	f; // 4 octets
double	d; // 8 octets
```
Un octet c'est 8 bits et donc 8 interrupteurs.\
Dans un int, on a 32 interrupteurs\
[â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘]\
En ecrivant 42 dans un int (`int n = 42;`), c'est comme si je devais chercher 32 interrupteurs pour reprÃ©senter la creation de ce int et je vais allumer les interrupteurs 0, 1, 3, 5 :\
[â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–‘][â–ˆ][â–‘][â–ˆ][â–‘][â–ˆ][â–‘]\
Ce que j'aime bien avec cette representation, c'est qu'on se rend compte que pour stocker 42, on a utilisÃ© enormement d'interrupteurs alors qu'on aurait pu en utiliser beaucoup moins avec un autre type de donnÃ©es.\

Dans ce module, on va creer une classe qui va stocker un nombre a virgule flottante : Fixed.hpp\
Dans cette classe, on a beosin d'un entier pour stocker la valeur du nombre en virgule fixe.\
Ensuite, on va avoir besoin d'un entier constant statique pour stocker le nombre de bits de la partie
fractionnaire, et dont la valeur sera toujours le littÃ©ral entier 8.
```cpp
class Fixed
{
public:
	Fixed(void);
	Fixed(const Fixed &rhs);
	Fixed(const int n);
	Fixed(const float f);
	~Fixed(void);
	Fixed	&operator=(const Fixed &rhs);
	int		getRawBits(void) const;
	void	setRawBits(int const raw);
	float	toFloat(void) const;
	int		toInt(void) const;

private:
	int					value_;
	static const int	fractionalBits_ = 8;
};
```
Pour l'instant, pas besoin de faire attention Ã  toutes les fonctions, on va juste s'interesser Ã  la partie `value_` et `fractionalBits_`.\
`value_` est un entier qui va stocker la valeur du nombre en virgule fixe.\
`fractionalBits_` est un entier constant statique qui va stocker le nombre de bits de la partie fractionnaire.\
La partie fractionnaire est la partie du nombre qui vient aprÃ¨s la virgule.\
Donc si on a 42.75, la partie fractionnaire est 0.75.\
On a besoin de 8 bits pour stocker la partie fractionnaire.\
```bash
101010.11
```
Dans cette exemple, on a besoin de 6 bits pour stocker la partie entiÃ¨re et 2 bits pour stocker la partie fractionnaire.\
Dans la classe Fixed, on a besoin de 8 bits pour stocker la partie fractionnaire :\
[â–‘][â–‘][â–‘][â–‘] [â–‘][â–‘][â–‘][â–‘]\
Pour 0.75, on va allumer les interrupteurs suivants :\
[â–ˆ][â–ˆ][â–‘][â–‘] [â–‘][â–‘][â–‘][â–‘]\
```bash
1100 0000 -> 2^(-1) * 1 + 2^(-2) * 1 = 0.75
# la partie fractionnaire maximum qu'on peut atteindre avec 8 bits :
1111 1111 = 0.99609375
```
